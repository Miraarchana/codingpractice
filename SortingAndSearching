Sorting and searching

Merge 2 sorted arrays:
  
        - comparing two arrays from beginning and keep adding elements in ascending order
                    * time - O(mn) , space - O(mn)


public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] mergedArray = new int[m + n];
        /**
        merge in a new array
        */
        int k =0, i=0, j=0;
        while(i < m.length || j < n.length){
            if(nums1[i] < nums2[j])
                mergedArray[k++] = nums1[i++];
            else
                mergedArray[k++] = nums2[j++];
        }
        while(i < m.length){
            mergedArray[k++] = nums1[i++];
        }
        while(j < n.length){
            mergedArray[k++] = nums2[j++];
        }
}



        -In-place :
 if there are enough space in nums1 to hold nums2, compare from last value
                    *time - O(mn) space - O(1)


public void merge(int[] nums1, int m, int[] nums2, int n) {
       /**
            merge in-place
        */
        int i=n-1; int j=n-1; int k = (m+n)-1;
        
        while(j>=0){
            if(i >=0 && nums1[i] > nums2[j]){
                nums1[k--] = nums1[i--];
            }else{
                nums1[k--] = nums2[j--];
            }
        }
    }

Merge K sorted arrays
merge K sorted array
           [2,3,4] [5,6,7] [8,9,10]
    possible 1:
merge and sort all the array
any merge is nlogn  = kn log(kn)
    possible 2:
merging one index of all array at a time 
                        kn * k
    possible 3:
      using a priority queue
      adding to PQ = log n
                  remove from PQ = constant time
                  kn log k


private static class QueueNode implements Comparable<QueueNode>{
        int arrayName , index, value;
        public QueueNode(int arrayName, int index, int value){
            this.arrayName = arrayName;
            this.index = index;
            this.value = value;
        }
        public int compareTo(QueueNode n){
            if(value > n.value) return 1;
            if(value < n.value) return -1;
            return 0;
        }
    }
        
    public static int[] mergeKSortedArrays(int[][] arrays){
        PriorityQueue<QueueNode> pq = new PriorityQueue<QueueNode>();
        int size =0;
        for(int i =0; i < arrays.length ; i++){
            size +=arrays[i].length;
            pq.add(new QueueNode(i, 0,arrays[i][0]));
        }
        int[] result = new int[size];
        for(int visit=0; !pq.isEmpty(); visit++){
            QueueNode node = pq.poll();
            result[visit] = node.value;
            int newIndex = node.index+1;
            if(newIndex < arrays[node.arrayName].length){
              pq.add(new QueueNode(node.arrayName, newIndex, arrays[node.arrayName][newIndex]));  
            }
        }  
        return result;
    }



Sort color (0,1,2)



   // 1, 0, 2, 0, 2
    //^^             ^
    //LM           H
    
    public void sortColors(int[] nums) {
        int low =-1;
        int mid =0;
        int high = nums.length;
        while(mid<high){
            if(nums[mid]==1)
                mid++; // if 1, the mid pointer moves up
            else if(nums[mid]==0){
                ++low; // if 0, low pointer is moved up, swap and increase mid
                swap(nums, mid,low);
                mid++; 
            }else{
                high--; // if 2, high is moved down and swap
                swap(nums, mid,high);
            }
        }
    }
    void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i]= nums[j];
        nums[j] = temp;
    }



Ascending order sorted and rotated array
Steps to solve without duplicates
Find minimum number index / rotation point index in an array
Initialise left = 0 , right = nums.length-1
Loop till left < right (don’t check left ==right, that is the break point for this loop as Left and right will point to Min value)
Find pivot mid = (left +right)/2
If pivot index value > right, right-side has the shifting point, left = pivot+1;
( as we have to move towards the rotation point). 
Else search in Left side. Right = pivot
Return min value.

public int findMin(int[] nums) {
        int left =0;
        int right = nums.length -1;
        int pivot = 0;
        while(left < right){
            pivot = (left +right)/2;
            if(nums[pivot] > nums[right]){
                left =pivot+1;
            }
            else{
                right = pivot;
            }
        }
        
        return nums[left];
    }


Search in Rotated array for target
Initialise left =0; right = nums.length-1;
Loop until Left <= Right (left == right is included in this case as we are searching for a target value & chances of its presence must be checked till end)
Find the pivot = (left+right)/2
If nums[pivot] == target return true;
Determine the rotated side and check the target in two cases
Case 1: nums[pivot] >=nums[left] -> shift point is in right side
If nums[left] <= target<nums[mid]  → chk target lies in the left side
Right = pivot-1;
Else
	Left = pivot+1;
Case 2:else -> shift point is in left side
If nums[left] <= target<nums[mid]  →chk target lies in the right side
left = pivot+1;
Else
	right = pivot-1;
Return false

public int search(int[] nums, int target) {
        int left =0;
        int right = nums.length -1;
        while(left <= right){
            int mid = (left+right)/2;
            if(nums[mid] == target){
                return mid;
            }
            if(nums[left]<= nums[mid]){
                if(nums[left] <= target && target < nums[mid]){//[4,5,6,7,0,1,2]
                    right = mid-1;
                }else{
                    left = mid+1;
                }
            }else{
                if(nums[mid] < target && target <= nums[right]){ //[5,6,0,1,2,3,4]
                    left = mid+1;
                }else{
                    right = mid-1;
                }
            }
        }
        return -1;  
    }

Steps to solve with duplicates
Find minimum number index / rotation point index in an array
Initialise left = 0 , right = nums.length-1
Loop till left < right (don’t check left ==right, that is the break point for this loop as Left and right will point to Min value)
Loop until nums[left] == nums[right] && left!=right and increment left++ (This takes care of duplicate values)
Find pivot mid = (left +right)/2
If pivot index value > right, right-side has the shifting point, left = pivot+1;
( as we have to move towards the rotation point). Else search in Left side. Right = pivot
Return min value.

public int findMin(int[] nums) {
        int left =0;
        int right = nums.length -1;
        int pivot = 0;
        while(left < right){
            //input: [3,3,1,3] will return 3 as answer. to fix that we keep moving the left pointer if Left and Right has same number
            while(nums[left] == nums[right] && left!=right){
                left++;
            }
            pivot = (left +right)/2;
            if(nums[pivot] > nums[right]){
                left =pivot+1;
            }
            else{
                right = pivot;
            }
        }
        return nums[left];
    }

Search in Rotated array for target
Initialise left =0; right = nums.length-1;
Loop until Left <= Right (left == right is included in this case as we are searching for a target value & chances of its presence must be checked till end)
Loop until nums[left] == nums[right] && left!=right and increment left++ (This takes care of duplicate values)
Find the pivot = (left+right)/2
If nums[pivot] == target return true;
Determine the rotated side and check the target in two cases
Case 1: nums[pivot] >=nums[left] -> shift point is in right side
If nums[left] <= target<nums[mid]  → chk target lies in the left side
Right = pivot-1;
Else
	Left = pivot+1;
Case 2:else -> shift point is in left side
If nums[left] <= target<nums[mid]  →chk target lies in the right side
left = pivot+1;
Else
	right = pivot-1;
Return false

public boolean search(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left <= right){
            while(nums[left] == nums[right] && left!=right){
                left++;
            }
            int mid = (left + right)/2;
            if(nums[mid] == target)
                return true;
            //Find the rotation point side
            if(nums[left]<= nums[mid])//right side has the shift point
            {
                if(nums[left]<= target && target < nums[mid])
                    right = mid -1;
                else
                    left = mid+1;
            }
            else{ //left side has the shift point
                if(nums[mid] < target && target <=nums[right])
                    left = mid +1;
                else
                    right = mid-1;
            }
        }
        return false;
    }



